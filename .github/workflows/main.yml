name: Push Webhook (branch, commit, user)

on:
  push:
    branches:
      - '**'
  workflow_dispatch:
  
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  notify:
    if: github.ref_name != 'bk'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      TARGET_URL: ${{ secrets.WEBHOOK_URL }}
      MAX_ATTEMPTS: '3'
      BACKOFF_SECONDS: '60'
      FAIL_ON_ERROR: 'true'
      AWS_REGION: ${{ secrets.AWS_REGION }}
      SQS_QUEUE_URL: ${{ secrets.SQS_QUEUE_URL }}
      SQS_MESSAGE_GROUP: ${{ secrets.SQS_MESSAGE_GROUP }}
      WAIT_SECONDS: '90'

    steps:
      - name: Configure AWS credentials (static keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build payloads, print, send to SQS, then POST minimal payload to endpoint
        shell: bash
        run: |
          set -euo pipefail

          REPO="${{ github.event.repository.name }}"
          OWNER="${{ github.repository_owner }}"
          FULL_REPO="${OWNER}/${REPO}"
          REF="${{ github.ref }}"
          BRANCH="${{ github.ref_name }}"
          SHA="${{ github.sha }}"
          ACTOR="${{ github.actor }}"
          COMMIT_MSG="${{ github.event.head_commit.message || '' }}"
          COMMIT_AUTHOR_NAME="${{ github.event.head_commit.author.name || '' }}"
          COMMIT_AUTHOR_EMAIL="${{ github.event.head_commit.author.email || '' }}"
          COMMIT_URL="https://github.com/${FULL_REPO}/commit/${SHA}"

          # IDs
          SENDER_ID="${{ github.event.sender.id }}"

          # Obtener info del commit desde GitHub API
          resp=$(curl -sS \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${FULL_REPO}/commits/${SHA}" || true)

          AUTHOR_ID=$(echo "$resp" | jq -r '.author.id // .committer.id // empty')
          AUTHOR_LOGIN=$(echo "$resp" | jq -r '.author.login // empty')

          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # ğŸ” Fallbacks para commit message, autor y github_id
          # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          if [ -z "$COMMIT_MSG" ] || [ "$COMMIT_MSG" = "null" ]; then
            echo "âš ï¸ Commit message vacÃ­o, obteniendo desde API..."
            COMMIT_MSG=$(echo "$resp" | jq -r '.commit.message // empty' || echo "")
          fi
          if [ -z "$COMMIT_AUTHOR_NAME" ] || [ "$COMMIT_AUTHOR_NAME" = "null" ]; then
            COMMIT_AUTHOR_NAME=$(echo "$resp" | jq -r '.commit.author.name // empty' || echo "")
          fi
          if [ -z "$COMMIT_AUTHOR_EMAIL" ] || [ "$COMMIT_AUTHOR_EMAIL" = "null" ]; then
            COMMIT_AUTHOR_EMAIL=$(echo "$resp" | jq -r '.commit.author.email // empty' || echo "")
          fi
          if [ -z "$AUTHOR_ID" ] || [ "$AUTHOR_ID" = "null" ]; then
            AUTHOR_ID="$SENDER_ID"
          fi
          if [ -z "$AUTHOR_LOGIN" ] || [ "$AUTHOR_LOGIN" = "null" ]; then
            AUTHOR_LOGIN=$(echo "$resp" | jq -r '.commit.committer.login // empty' || echo "")
          fi

          # Si aÃºn falta autor, usa committer
          if [ -z "$COMMIT_AUTHOR_NAME" ] || [ -z "$COMMIT_AUTHOR_EMAIL" ]; then
            NAME_ALT=$(echo "$resp" | jq -r '.commit.committer.name // empty' || echo "")
            EMAIL_ALT=$(echo "$resp" | jq -r '.commit.committer.email // empty' || echo "")
            if [ -z "$COMMIT_AUTHOR_NAME" ] || [ "$COMMIT_AUTHOR_NAME" = "null" ]; then
              COMMIT_AUTHOR_NAME="$NAME_ALT"
            fi
            if [ -z "$COMMIT_AUTHOR_EMAIL" ] || [ "$COMMIT_AUTHOR_EMAIL" = "null" ]; then
              COMMIT_AUTHOR_EMAIL="$EMAIL_ALT"
            fi
          fi

          # Defaults finales
          COMMIT_MSG="${COMMIT_MSG:-(sin mensaje de commit)}"
          COMMIT_AUTHOR_NAME="${COMMIT_AUTHOR_NAME:-(autor desconocido)}"
          COMMIT_AUTHOR_EMAIL="${COMMIT_AUTHOR_EMAIL:-(correo desconocido)}"
          AUTHOR_ID="${AUTHOR_ID:-0}"
          AUTHOR_LOGIN="${AUTHOR_LOGIN:-(usuario desconocido)}"

          echo "ğŸ“ Commit message: $COMMIT_MSG"
          echo "ğŸ‘¤ Autor: $COMMIT_AUTHOR_NAME <$COMMIT_AUTHOR_EMAIL>"
          echo "ğŸ†” GitHub ID: $AUTHOR_ID ($AUTHOR_LOGIN)"

          # Identificador de ejecuciÃ³n
          TIMESTAMP_MS=$(date +%s%3N)
          EXECUTION_ID="${SENDER_ID}-${TIMESTAMP_MS}"

          # ============ Payload COMPLETO (para SQS) ============
          PAYLOAD="$(jq -n \
            --arg repo "$REPO" \
            --arg owner "$OWNER" \
            --arg full "$FULL_REPO" \
            --arg ref "$REF" \
            --arg branch "$BRANCH" \
            --arg sha "$SHA" \
            --arg url "$COMMIT_URL" \
            --arg msg "$COMMIT_MSG" \
            --arg an "$COMMIT_AUTHOR_NAME" \
            --arg ae "$COMMIT_AUTHOR_EMAIL" \
            --arg actor "$ACTOR" \
            --arg sender_id "$SENDER_ID" \
            --arg author_id "$AUTHOR_ID" \
            --arg author_login "$AUTHOR_LOGIN" \
            --arg exec_id "$EXECUTION_ID" \
            '{
              repository: { name: $repo, owner: $owner, full_name: $full },
              ref: $ref,
              branch: $branch,
              commit: {
                sha: $sha,
                url: $url,
                message: $msg,
                author: {
                  name: $an,
                  email: $ae,
                  github_id: $author_id,
                  githubLogin: $author_login
                }
              },
              actor: $actor,
              executionId: $exec_id,
              senderId: $sender_id
            }'
          )"
          echo "$PAYLOAD" | jq . > payload.json
          echo "âœ… payload.json bytes: $(wc -c < payload.json)"

          echo ""
          echo "ğŸ“¦ Payload para SQS (completo):"
          jq . payload.json || cat payload.json
          echo ""

          # ============ Payload MINIMAL (para ENDPOINT) ============
          jq -n \
            --arg exec_id "$EXECUTION_ID" \
            --arg gid "$SENDER_ID" \
            '{executionId:$exec_id, github_id:$gid}' > endpoint_payload.json

          echo "âœ… endpoint_payload.json bytes: $(wc -c < endpoint_payload.json)"
          echo ""
          echo "ğŸ¯ Payload para ENDPOINT (minimal):"
          jq . endpoint_payload.json || cat endpoint_payload.json
          echo ""

          # =======================
          # ğŸ‘‰ ENVIAR A SQS PRIMERO
          # =======================
          if [ -z "${SQS_QUEUE_URL:-}" ]; then
            echo "::error::SQS_QUEUE_URL vacÃ­o. Configura el secret."
            exit 1
          fi

          IS_FIFO="false"
          if echo "$SQS_QUEUE_URL" | grep -Eq '\.fifo$'; then
            IS_FIFO="true"
          fi

          MSG_GROUP="${SQS_MESSAGE_GROUP:-gha-webhook}"
          DEDUP_ID="${{ github.run_id }}-${{ github.run_attempt }}-${TIMESTAMP_MS}"

          echo "ğŸšš Enviando mensaje a SQS: $SQS_QUEUE_URL (FIFO=$IS_FIFO)"
          if [ "$IS_FIFO" = "true" ]; then
            aws sqs send-message \
              --queue-url "$SQS_QUEUE_URL" \
              --message-body file://payload.json \
              --message-group-id "$MSG_GROUP" \
              --message-deduplication-id "$DEDUP_ID" \
              > sqs_response.json
          else
            aws sqs send-message \
              --queue-url "$SQS_QUEUE_URL" \
              --message-body file://payload.json \
              > sqs_response.json
          fi

          echo "âœ… SQS MessageId: $(jq -r '.MessageId' sqs_response.json)"

          # =======================
          # ğŸ•’ Esperar antes del webhook
          # =======================
          echo "â³ Esperando ${WAIT_SECONDS}s para continuar..."
          sleep "${WAIT_SECONDS}"
          echo "âœ… Continuando con el envÃ­o al endpoint..."

          # =======================
          # Llamar al ENDPOINT (con payload minimal)
          # =======================
          if [ -z "${TARGET_URL:-}" ]; then
            echo "::error::TARGET_URL vacÃ­o. Revisa Settings > Secrets (WEBHOOK_URL)."
            exit 1
          fi

          TARGET_URL_TRIMMED="$(printf '%s' "$TARGET_URL" | tr -d '\r' | sed -e 's/^[[:space:]]\+//' -e 's/[[:space:]]\+$//')"
          case "$TARGET_URL_TRIMMED" in
            \"*\" ) TARGET_URL_TRIMMED="${TARGET_URL_TRIMMED%\"}"; TARGET_URL_TRIMMED="${TARGET_URL_TRIMMED#\"}";;
            \'*\' ) TARGET_URL_TRIMMED="${TARGET_URL_TRIMMED%\'}"; TARGET_URL_TRIMMED="${TARGET_URL_TRIMMED#\'}";;
          esac
          if ! echo "$TARGET_URL_TRIMMED" | grep -Eqi '^https?://'; then
            echo "::error::WEBHOOK_URL no parece http(s) vÃ¡lido: '$TARGET_URL_TRIMMED'"
            exit 1
          fi
          TARGET_URL="$TARGET_URL_TRIMMED"

          attempt=1
          ok=false
          final_status=""

          while [ "$attempt" -le "${MAX_ATTEMPTS}" ]; do
            echo ""
            echo "ğŸš€ Intento $attempt/${MAX_ATTEMPTS} â€” enviando webhook..."
            HTTP_CODE=$(curl -sS -o response.json -w "%{http_code}" \
              -X POST "$TARGET_URL" \
              -H "Content-Type: application/json" \
              --data-binary "@endpoint_payload.json" || echo "000")

            echo "HTTP: $HTTP_CODE"
            if [ "$HTTP_CODE" != "200" ]; then
              echo "::error::HTTP code != 200 (${HTTP_CODE}). Se detiene aquÃ­."
              echo "ğŸ“¦ Cuerpo de respuesta (HTTP ${HTTP_CODE}):"
              jq . response.json 2>/dev/null || cat response.json || echo "(sin contenido)"
              final_status="http-${HTTP_CODE}"
              break
            fi

            status_val=$(jq -r '.status // empty | ascii_downcase' response.json 2>/dev/null || echo "")
            final_status="$status_val"
            echo "ğŸ“Œ status='${status_val}'"

            if [ "$status_val" = "in-process" ] || [ "$status_val" = "in_process" ]; then
              echo "â³ Proceso en curso; esperando ${BACKOFF_SECONDS}s antes del siguiente intento..."
              attempt=$((attempt+1))
              sleep "${BACKOFF_SECONDS}"
              continue
            fi

            echo ""
            echo "ğŸ“¦ Respuesta completa del servidor (status â‰  in-process):"
            jq . response.json || cat response.json

            if [ "$status_val" = "success" ]; then
              ok=true
              echo "âœ… Proceso finalizado con Ã©xito."
              break
            elif [ "$status_val" = "fail" ] || [ "$status_val" = "failed" ] || [ "$status_val" = "error" ]; then
              ok=false
              echo "::error::Proceso finalizÃ³ con estado '${status_val}'."
              break
            else
              ok=false
              echo "::warning::Status no reconocido ('${status_val}'); se detiene."
              break
            fi
          done

          if [ "$ok" != "true" ]; then
            echo "âŒ Webhook no terminÃ³ en success (resultado='${final_status}')."
            if [ "${FAIL_ON_ERROR}" = "true" ]; then exit 1; fi
            echo "::warning::Continuando sin fallar el job."
          fi
