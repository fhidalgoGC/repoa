name: Push Webhook (branch, commit, user)

on:
  push:
    branches:
      - '**'
  workflow_dispatch:

concurrency:
  group: push-webhook
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  notify:
    if: github.ref_name != 'bk' # ‚õî no ejecutar en esta rama (ajusta si quieres)
    runs-on: ubuntu-latest
    env:
      TARGET_URL: ${{ secrets.WEBHOOK_URL }}
      MAX_ATTEMPTS: '3'
      BACKOFF_SECONDS: '60'
      FAIL_ON_ERROR: 'true'
      AWS_REGION: ${{ secrets.AWS_REGION }}
      SQS_QUEUE_URL: ${{ secrets.SQS_QUEUE_URL }}
      SQS_MESSAGE_GROUP: ${{ secrets.SQS_MESSAGE_GROUP }}
      WAIT_SECONDS: '60' # ‚è≥ tiempo de espera despu√©s de enviar SQS (en segundos)

    steps:
      # 1Ô∏è‚É£ Configurar credenciales AWS
      - name: Configure AWS credentials (static keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # 2Ô∏è‚É£ Construir payload, enviar a SQS y luego al endpoint
      - name: Build payload, send to SQS, then POST to endpoint
        shell: bash
        run: |
          set -euo pipefail

          REPO="${{ github.event.repository.name }}"
          OWNER="${{ github.repository_owner }}"
          FULL_REPO="${OWNER}/${REPO}"
          REF="${{ github.ref }}"
          BRANCH="${{ github.ref_name }}"
          SHA="${{ github.sha }}"
          ACTOR="${{ github.actor }}"
          COMMIT_MSG="${{ github.event.head_commit.message || '' }}"
          COMMIT_AUTHOR_NAME="${{ github.event.head_commit.author.name || '' }}"
          COMMIT_AUTHOR_EMAIL="${{ github.event.head_commit.author.email || '' }}"
          COMMIT_URL="https://github.com/${FULL_REPO}/commit/${SHA}"

          # ID del usuario que hizo el push
          SENDER_ID="${{ github.event.sender.id }}"

          # Autor del commit (si est√° asociado a cuenta GitHub)
          resp=$(curl -sS \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${FULL_REPO}/commits/${SHA}" || true)
          AUTHOR_ID=$(echo "$resp" | jq -r '.author.id // empty')
          AUTHOR_LOGIN=$(echo "$resp" | jq -r '.author.login // empty')

          # executionId = <SENDER_ID>-<timestamp_ms>
          TIMESTAMP_MS=$(date +%s%3N)
          EXECUTION_ID="${SENDER_ID}-${TIMESTAMP_MS}"

          # Payload JSON
          PAYLOAD="$(jq -n \
            --arg repo "$REPO" \
            --arg owner "$OWNER" \
            --arg full "$FULL_REPO" \
            --arg ref "$REF" \
            --arg branch "$BRANCH" \
            --arg sha "$SHA" \
            --arg url "$COMMIT_URL" \
            --arg msg "$COMMIT_MSG" \
            --arg an "$COMMIT_AUTHOR_NAME" \
            --arg ae "$COMMIT_AUTHOR_EMAIL" \
            --arg actor "$ACTOR" \
            --arg sender_id "$SENDER_ID" \
            --arg author_id "$AUTHOR_ID" \
            --arg author_login "$AUTHOR_LOGIN" \
            --arg exec_id "$EXECUTION_ID" \
            '{
              repository: { name: $repo, owner: $owner, full_name: $full },
              ref: $ref,
              branch: $branch,
              commit: {
                sha: $sha,
                url: $url,
                message: $msg,
                author: {
                  name: $an,
                  email: $ae,
                  github_id: $author_id,
                  githubLogin: $author_login
                }
              },
              actor: $actor,
              executionId: $exec_id,
              senderId: $sender_id
            }'
          )"
          echo "$PAYLOAD" | jq . > payload.json
          echo "‚úÖ payload.json bytes: $(wc -c < payload.json)"

          # =======================
          # üëâ ENVIAR A SQS PRIMERO
          # =======================
          if [ -z "${SQS_QUEUE_URL:-}" ]; then
            echo "::error::SQS_QUEUE_URL vac√≠o. Configura el secret."
            exit 1
          fi

          IS_FIFO="false"
          if echo "$SQS_QUEUE_URL" | grep -Eq '\.fifo$'; then
            IS_FIFO="true"
          fi

          MSG_GROUP="${SQS_MESSAGE_GROUP:-gha-webhook}"
          DEDUP_ID="${{ github.run_id }}-${{ github.run_attempt }}-${TIMESTAMP_MS}"

          echo "üöö Enviando mensaje a SQS: $SQS_QUEUE_URL (FIFO=$IS_FIFO)"
          if [ "$IS_FIFO" = "true" ]; then
            aws sqs send-message \
              --queue-url "$SQS_QUEUE_URL" \
              --message-body file://payload.json \
              --message-group-id "$MSG_GROUP" \
              --message-deduplication-id "$DEDUP_ID" \
              > sqs_response.json
          else
            aws sqs send-message \
              --queue-url "$SQS_QUEUE_URL" \
              --message-body file://payload.json \
              > sqs_response.json
          fi

          echo "‚úÖ SQS MessageId: $(jq -r '.MessageId' sqs_response.json)"

          # =======================
          # üïí Esperar antes del webhook
          # =======================
          echo "‚è≥ Esperando ${WAIT_SECONDS}s para continuar..."
          sleep "${WAIT_SECONDS}"
          echo "‚úÖ Continuando con el env√≠o al endpoint..."

          # =======================
          # Luego llamar al ENDPOINT
          # =======================
          if [ -z "${TARGET_URL:-}" ]; then
            echo "::error::TARGET_URL vac√≠o. Revisa Settings > Secrets (WEBHOOK_URL) o push desde fork (sin secretos)."
            exit 1
          fi

          TARGET_URL_TRIMMED="$(printf '%s' "$TARGET_URL" | tr -d '\r' | sed -e 's/^[[:space:]]\+//' -e 's/[[:space:]]\+$//')"
          case "$TARGET_URL_TRIMMED" in
            \"*\" ) TARGET_URL_TRIMMED="${TARGET_URL_TRIMMED%\"}"; TARGET_URL_TRIMMED="${TARGET_URL_TRIMMED#\"}";;
            \'*\' ) TARGET_URL_TRIMMED="${TARGET_URL_TRIMMED%\'}"; TARGET_URL_TRIMMED="${TARGET_URL_TRIMMED#\'}";;
          esac

          if ! echo "$TARGET_URL_TRIMMED" | grep -Eqi '^https?://'; then
            echo "::error::WEBHOOK_URL no parece http(s) v√°lido: '$TARGET_URL_TRIMMED'"
            exit 1
          fi

          TARGET_HOST="$(printf '%s' "$TARGET_URL_TRIMMED" | awk -F/ '{print $1"//"$3}')"
          echo "‚úÖ Host destino: $TARGET_HOST"
          TARGET_URL="$TARGET_URL_TRIMMED"

          attempt=1
          ok=false
          final_status=""

          while [ "$attempt" -le "${MAX_ATTEMPTS}" ]; do
            echo ""
            echo "üöÄ Intento $attempt/${MAX_ATTEMPTS} ‚Äî enviando webhook..."
            HTTP_CODE=$(curl -sS -o response.json -w "%{http_code}" \
              -X POST "$TARGET_URL" \
              -H "Content-Type: application/json" \
              --data-binary "@payload.json" || echo "000")

            echo "HTTP: $HTTP_CODE"
            if [ "$HTTP_CODE" != "200" ]; then
              echo "::error::HTTP code != 200 (${HTTP_CODE}). Se detiene."
              final_status="http-${HTTP_CODE}"
              break
            fi

            status_val=$(jq -r '.status // empty | ascii_downcase' response.json 2>/dev/null || echo "")
            final_status="$status_val"
            echo "üìå status='${status_val}'"

            if [ "$status_val" = "in-process" ] || [ "$status_val" = "in_process" ]; then
              attempt=$((attempt+1))
              if [ "$attempt" -le "${MAX_ATTEMPTS}" ]; then
                echo "‚è≥ Proceso en curso; esperando ${BACKOFF_SECONDS}s antes del siguiente intento..."
                sleep "${BACKOFF_SECONDS}"
                continue
              fi
            else
              echo ""
              echo "üì¶ Respuesta completa del servidor (status ‚â† in-process):"
              jq . response.json || cat response.json
            fi

            if [ "$status_val" = "success" ]; then
              ok=true
              echo "‚úÖ Proceso finalizado con √©xito."
              break
            elif [ "$status_val" = "fail" ] || [ "$status_val" = "failed" ] || [ "$status_val" = "error" ] || [ -z "$status_val" ]; then
              ok=false
              echo "::error::Proceso finaliz√≥ con estado '${status_val}'."
              break
            else
              ok=false
              echo "::warning::Status no reconocido ('${status_val}'); se tratar√° como error."
              break
            fi
          done

          if [ "$ok" != "true" ]; then
            echo "‚ùå Webhook no termin√≥ en success (resultado='${final_status}')."
            if [ "${FAIL_ON_ERROR}" = "true" ]; then exit 1; fi
            echo "::warning::Continuando sin fallar el job."
          fi
