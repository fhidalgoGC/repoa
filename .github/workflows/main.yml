name: Push Webhook (branch, commit, user)

on:
  push:
    branches:
      - '**'
  workflow_dispatch:

concurrency:
  group: push-webhook
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  notify:
    if: github.ref_name != 'bk' # ‚õî no ejecutar en main (ajusta si quieres)
    runs-on: ubuntu-latest
    env:
      TARGET_URL: ${{ secrets.WEBHOOK_URL }}
      MAX_ATTEMPTS: '3'
      BACKOFF_SECONDS: '60' # espera entre intentos
      FAIL_ON_ERROR: 'true'
    steps:
      - name: Build payload and POST (validate URL + HTTP + status + print full JSON)
        shell: bash
        run: |
          set -euo pipefail

          REPO="${{ github.event.repository.name }}"
          OWNER="${{ github.repository_owner }}"
          FULL_REPO="${OWNER}/${REPO}"
          REF="${{ github.ref }}"
          BRANCH="${{ github.ref_name }}"
          SHA="${{ github.sha }}"
          ACTOR="${{ github.actor }}"
          COMMIT_MSG="${{ github.event.head_commit.message || '' }}"
          COMMIT_AUTHOR_NAME="${{ github.event.head_commit.author.name || '' }}"
          COMMIT_AUTHOR_EMAIL="${{ github.event.head_commit.author.email || '' }}"
          COMMIT_URL="https://github.com/${FULL_REPO}/commit/${SHA}"

          # ID del usuario que hizo el push
          SENDER_ID="${{ github.event.sender.id }}"

          # Autor del commit (si est√° asociado a cuenta GitHub)
          resp=$(curl -sS \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${FULL_REPO}/commits/${SHA}" || true)
          AUTHOR_ID=$(echo "$resp" | jq -r '.author.id // empty')
          AUTHOR_LOGIN=$(echo "$resp" | jq -r '.author.login // empty')

          # executionId = <SENDER_ID>-<timestamp_ms>
          TIMESTAMP_MS=$(date +%s%3N)
          EXECUTION_ID="${SENDER_ID}-${TIMESTAMP_MS}"

          # Payload
          PAYLOAD="$(jq -n \
            --arg repo "$REPO" \
            --arg owner "$OWNER" \
            --arg full "$FULL_REPO" \
            --arg ref "$REF" \
            --arg branch "$BRANCH" \
            --arg sha "$SHA" \
            --arg url "$COMMIT_URL" \
            --arg msg "$COMMIT_MSG" \
            --arg an "$COMMIT_AUTHOR_NAME" \
            --arg ae "$COMMIT_AUTHOR_EMAIL" \
            --arg actor "$ACTOR" \
            --arg sender_id "$SENDER_ID" \
            --arg author_id "$AUTHOR_ID" \
            --arg author_login "$AUTHOR_LOGIN" \
            --arg exec_id "$EXECUTION_ID" \
            '{
              repository: { name: $repo, owner: $owner, full_name: $full },
              ref: $ref,
              branch: $branch,
              commit: {
                sha: $sha,
                url: $url,
                message: $msg,
                author: {
                  name: $an,
                  email: $ae,
                  github_id: $author_id,
                  githubLogin: $author_login
                }
              },
              actor: $actor,
              executionId: $exec_id,
              senderId: $sender_id
            }'
          )"
          echo "$PAYLOAD" | jq . > payload.json
          echo "‚úÖ payload.json bytes: $(wc -c < payload.json)"
          echo "== PAYLOAD =="
          jq . payload.json

          # ===== Prechequeo de TARGET_URL =====
          if [ -z "${TARGET_URL:-}" ]; then
            echo "::error::TARGET_URL vac√≠o. Revisa Settings > Secrets (WEBHOOK_URL) o push desde fork (sin secretos)."
            exit 1
          fi
          TARGET_URL_TRIMMED="$(printf '%s' "$TARGET_URL" | tr -d '\r' | sed -e 's/^[[:space:]]\+//' -e 's/[[:space:]]\+$//')"
          case "$TARGET_URL_TRIMMED" in
            \"*\" ) TARGET_URL_TRIMMED="${TARGET_URL_TRIMMED%\"}"; TARGET_URL_TRIMMED="${TARGET_URL_TRIMMED#\"}";;
            \'*\' ) TARGET_URL_TRIMMED="${TARGET_URL_TRIMMED%\'}"; TARGET_URL_TRIMMED="${TARGET_URL_TRIMMED#\'}";;
          esac
          if ! echo "$TARGET_URL_TRIMMED" | grep -Eqi '^https?://'; then
            echo "::error::WEBHOOK_URL no parece http(s) v√°lido: '$TARGET_URL_TRIMMED'"
            exit 1
          fi
          TARGET_HOST="$(printf '%s' "$TARGET_URL_TRIMMED" | awk -F/ '{print $1"//"$3}')"
          echo "‚úÖ Host destino: $TARGET_HOST"
          echo "üîé URL (hex para detectar caracteres raros):"
          printf '%s' "$TARGET_URL_TRIMMED" | od -An -tx1 | tr -s ' ' | sed 's/^ *//'
          TARGET_URL="$TARGET_URL_TRIMMED"
          # ====================================

          attempt=1
          ok=false
          final_status=""
          while [ "$attempt" -le "${MAX_ATTEMPTS}" ]; do
            echo ""
            echo "üöÄ Intento $attempt/${MAX_ATTEMPTS} ‚Äî enviando webhook..."
            if [ "$attempt" -eq 1 ]; then
              echo "‚û°Ô∏è curl -sS -o response.json -w \"%{http_code}\" -X POST \"$TARGET_URL\" -H 'Content-Type: application/json' --data-binary @payload.json"
            fi

            HTTP_CODE=$(curl -sS -o response.json -w "%{http_code}" \
              -X POST "$TARGET_URL" \
              -H "Content-Type: application/json" \
              --data-binary "@payload.json" || echo "000")

            echo "HTTP: $HTTP_CODE"
            if [ "$HTTP_CODE" != "200" ]; then
              echo "::error::HTTP code != 200 (${HTTP_CODE}). Se detiene."
              final_status="http-${HTTP_CODE}"
              break
            fi

            status_val=$(jq -r '.status // empty | ascii_downcase' response.json 2>/dev/null || echo "")
            final_status="$status_val"
            echo "üìå status='${status_val}'"

            if [ "$status_val" = "in-process" ] || [ "$status_val" = "in_process" ]; then
              attempt=$((attempt+1))
              if [ "$attempt" -le "${MAX_ATTEMPTS}" ]; then
                echo "‚è≥ Proceso en curso; esperando ${BACKOFF_SECONDS}s antes del siguiente intento..."
                sleep "${BACKOFF_SECONDS}"
                continue
              fi
            else
              echo ""
              echo "üì¶ Respuesta completa del servidor (status ‚â† in-process):"
              jq . response.json || cat response.json
            fi

            if [ "$status_val" = "success" ]; then
              ok=true
              echo "‚úÖ Proceso finalizado con √©xito."
              break
            elif [ "$status_val" = "fail" ] || [ "$status_val" = "failed" ] || [ "$status_val" = "error" ] || [ -z "$status_val" ]; then
              ok=false
              echo "::error::Proceso finaliz√≥ con estado '${status_val}'."
              break
            else
              ok=false
              echo "::warning::Status no reconocido ('${status_val}'); se tratar√° como error."
              break
            fi
          done

          if [ "$ok" != "true" ]; then
            echo "‚ùå Webhook no termin√≥ en success (resultado='${final_status}')."
            if [ "${FAIL_ON_ERROR}" = "true" ]; then exit 1; fi
            echo "::warning::Continuando sin fallar el job."
          fi
